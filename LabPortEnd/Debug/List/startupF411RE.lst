###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         30/Aug/2018  15:31:19
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\startupF411RE.cpp
#    Command line =  
#        -f C:\Users\Sergey\AppData\Local\Temp\EWE1C8.tmp
#        (E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\startupF411RE.cpp -lcN
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Debug\List -lb
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Debug\List -o
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Debug\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\ -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Application\ -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Common\ -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\AHardware\ -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\AHardware\GpioPort\ -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\AHardware\IrqController\ -I
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\CMSIS\ -Om --c++
#        --no_exceptions --no_rtti)
#    Locale       =  C
#    List file    =  
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Debug\List\startupF411RE.lst
#    Object file  =  
#        E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\Debug\Obj\startupF411RE.o
#
###############################################################################

E:\Projects\ARM_LAB\stm32Labs\LabPortEnd\startupF411RE.cpp
      1          /******************************************************************************
      2           *  FILENAME: startupF411RE.cpp
      3           *  
      4           * DESCRIPTION: Файл с векторами прерывания для Cortex-M. для С++.
      5           * Поскольку почему-то в Cortex-M все обработчики должны по имени точно 
      6           *  совпадать с имена в таблице векторов, а название метода из С++ класса 
      7           * совпасть с такой таблицей со стандратными стартап файлами никак не может
      8           * то вот приходиться такой же писать на С++. 
      9           * Внимание!!!!!! Имена классов точно должны совпадать с именами у вас в проекте
     10           * Можно изменить и сократить количество классов, если есть желание, например
     11           *
     12           * Copyright (c) 2018 by South Ural State University
     13           * Author: Сергей Колодий
     14           ******************************************************************************/
     15          
     16          #pragma language = extended
     17          #pragma segment = "CSTACK"
     18          #include "AHardware/IrqController/irqcontroller.hpp"
     19          
     20          extern "C" void __iar_program_start( void );
     21          
     22          namespace OsWrapper
     23          {
     24            class Rtos
     25            {
     26            public:
     27              static void HandleSvcInterrupt();
     28              static void HandleSvInterrupt();
     29              static void HandleSysTickInterrupt();
     30            };
     31          };
     32          
     33          class DummyModule
     34          {
     35            public:
     36              static void handler();
     37          };
     38          
     39          using tIntFunct = void(*)();
     40          //cstat !MISRAC++2008-9-5-1
     41          using tIntVectItem = union {tIntFunct __fun; void * __ptr;};
     42          
     43          // The vector table is normally located at address 0.
     44          // When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
     45          // If you need to define interrupt service routines,
     46          // make a copy of this file and include it in your project.
     47          // The name "__vector_table" has special meaning for C-SPY:
     48          // it is where the SP start value is found, and the NVIC vector
     49          // table register (VTOR) is initialized to this address if != 0.
     50          
     51          #pragma location = ".intvec"
     52          //cstat !MISRAC++2008-0-1-4_b !MISRAC++2008-9-5-1
     53          extern "C" const tIntVectItem __vector_table[] =
     54          {
     55            { .__ptr = __sfe( "CSTACK" ) },
     56            __iar_program_start,
     57          
     58            DummyModule::handler,
     59            DummyModule::handler,
     60            DummyModule::handler,
     61            DummyModule::handler,
     62            DummyModule::handler,
     63            0,
     64            0,
     65            0,
     66            0,
     67            OsWrapper::Rtos::HandleSvcInterrupt,             
     68            DummyModule::handler,
     69            0,
     70            OsWrapper::Rtos::HandleSvInterrupt,          
     71            OsWrapper::Rtos::HandleSysTickInterrupt,         
     72            //External Interrupts
     73            DummyModule::handler,         //Window Watchdog
     74            DummyModule::handler,         //PVD through EXTI Line detect/EXTI16
     75            DummyModule::handler,         //Tamper and Time Stamp/EXTI21 
     76            DummyModule::handler,         //RTC Wakeup/EXTI22 
     77            DummyModule::handler,         //FLASH
     78            DummyModule::handler,         //RCC
     79            DummyModule::handler,         //EXTI Line 0
     80            DummyModule::handler,         //EXTI Line 1
     81            DummyModule::handler,         //EXTI Line 2
     82            DummyModule::handler,         //EXTI Line 3
     83            DummyModule::handler,         //EXTI Line 4
     84            DummyModule::handler,         //DMA1 Stream 0
     85            DummyModule::handler,         //DMA1 Stream 1
     86            DummyModule::handler,         //DMA1 Stream 2
     87            DummyModule::handler,         //DMA1 Stream 3
     88            DummyModule::handler,         //DMA1 Stream 4
     89            DummyModule::handler,         //DMA1 Stream 5
     90            DummyModule::handler,         //DMA1 Stream 6
     91            DummyModule::handler,         //ADC1
     92            0,                            //USB High Priority
     93            0,                            //USB Low  Priority
     94            0,                            //DAC
     95            0,                            //COMP through EXTI Line
     96            DummyModule::handler,         //EXTI Line 9..5
     97            DummyModule::handler,         //TIM9/TIM1 Break interrupt 
     98            DummyModule::handler,         //TIM10/TIM1 Update interrupt
     99            DummyModule::handler,         //TIM11/TIM1 Trigger/Commutation interrupts
    100            DummyModule::handler,		//TIM1 Capture Compare interrupt
    101            DummyModule::handler,         //TIM2  	
    102            DummyModule::handler,         //TIM3
    103            DummyModule::handler,         //TIM4
    104            DummyModule::handler,         //I2C1 Event
    105            DummyModule::handler,         //I2C1 Error
    106            DummyModule::handler,         //I2C2 Event
    107            DummyModule::handler,         //I2C2 Error
    108            DummyModule::handler,         //SPI1
    109            DummyModule::handler,         //SPI2
    110            DummyModule::handler,         //USART1
    111            DummyModule::handler,         //USART2
    112            0,
    113            IrqController::HandleIrqExtiLine15_10,         //EXTI Line 15..10
    114            DummyModule::handler,         //EXTI Line 17 interrupt / RTC Alarms (A and B) through EXTI line interrupt
    115            DummyModule::handler,         //EXTI Line 18 interrupt / USB On-The-Go  FS Wakeup through EXTI line interrupt
    116            0,				//TIM6
    117            0,				//TIM7  f0
    118            0,
    119            0,
    120            DummyModule::handler,         //DMA1 Stream 7 global interrupt fc
    121            0,
    122            DummyModule::handler,	        //SDIO global interrupt
    123            DummyModule::handler,	        //TIM5 global interrupt
    124            DummyModule::handler,	        //SPI3 global interrupt
    125            0,			        // 110
    126            0,
    127            0,
    128            0,
    129            DummyModule::handler,		//DMA2 Stream0 global interrupt 120
    130            DummyModule::handler,		//DMA2 Stream1 global interrupt
    131            DummyModule::handler,		//DMA2 Stream2 global interrupt
    132            DummyModule::handler,		//DMA2 Stream3 global interrupt
    133            DummyModule::handler,		//DMA2 Stream4 global interrupt 130
    134            0,
    135            0,
    136            0,
    137            0,
    138            0,
    139            0,
    140            DummyModule::handler,		//USB On The Go FS global interrupt, 14C
    141            DummyModule::handler,		//DMA2 Stream5 global interrupt
    142            DummyModule::handler,		//DMA2 Stream6 global interrupt
    143            DummyModule::handler,		//DMA2 Stream7 global interrupt
    144            DummyModule::handler,				//USART6 15C
    145            DummyModule::handler,         //I2C3 Event
    146            DummyModule::handler,         //I2C3 Error 164
    147            0,
    148            0,
    149            0,
    150            0,
    151            0,
    152            0,
    153            0,
    154            DummyModule::handler,		//FPU 184
    155            0,
    156            0,
    157            DummyModule::handler,		//SPI 4 global interrupt
    158            DummyModule::handler		//SPI 5 global interrupt
    159          };
    160          
    161          void DummyModule::handler()   { for(;;) {} } ;
    162          __weak void OsWrapper::Rtos::HandleSvcInterrupt() { for(;;) {} } ;
    163          __weak void OsWrapper::Rtos::HandleSvInterrupt() { for(;;) {} } ;
    164          __weak void OsWrapper::Rtos::HandleSysTickInterrupt() { for(;;) {} } ;
    165          
    166          extern "C" void __cmain( void );
    167          extern "C" __weak void __iar_init_core( void );
    168          extern "C" __weak void __iar_init_vfp( void );
    169          
    170          #pragma required=__vector_table
    171          void __iar_program_start( void )
    172          {
    173            __iar_init_core();
    174            __iar_init_vfp();
    175            __cmain();
    176          }
    177          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DummyModule::handler()
       0   OsWrapper::Rtos::HandleSvInterrupt()
       0   OsWrapper::Rtos::HandleSvcInterrupt()
       0   OsWrapper::Rtos::HandleSysTickInterrupt()
       8   __iar_program_start
         0   -> __cmain
         8   -> __iar_init_core
         8   -> __iar_init_vfp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  DummyModule::handler()
       2  OsWrapper::Rtos::HandleSvInterrupt()
       2  OsWrapper::Rtos::HandleSvcInterrupt()
       2  OsWrapper::Rtos::HandleSysTickInterrupt()
      18  __iar_program_start
     408  __vector_table

 
 408 bytes in section .intvec
  26 bytes in section .text
 
  20 bytes of CODE  memory (+ 6 bytes shared)
 408 bytes of CONST memory

Errors: none
Warnings: none
